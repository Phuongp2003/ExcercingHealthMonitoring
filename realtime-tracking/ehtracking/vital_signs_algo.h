#ifndef VITAL_SIGNS_ALGO_H
#define VITAL_SIGNS_ALGO_H

#include "config.h"
#include <math.h>

// Hàm lọc thông dải Butterworth bậc 2 (0.5-4Hz)
static void bandpass_filter(const float *input, float *output, int len, float fs) {
    // Coefficients for 2nd order Butterworth bandpass (0.5-4Hz, fs=40Hz)
    // Generated by scipy.signal.butter(2, [0.5, 4], btype='band', fs=40)
    // b = [0.0675, 0, -0.135, 0, 0.0675], a = [1, -3.06, 3.44, -1.79, 0.393]
    // For simplicity, use a simple IIR filter (not optimal, but enough for demo)
    float a1 = -3.06f, a2 = 3.44f, a3 = -1.79f, a4 = 0.393f;
    float b0 = 0.0675f, b2 = -0.135f, b4 = 0.0675f;
    float x1=0, x2=0, x3=0, x4=0, y1=0, y2=0, y3=0, y4=0;
    for (int i = 0; i < len; i++) {
        float x0 = input[i];
        float y0 = b0*x0 + b2*x2 + b4*x4 - a1*y1 - a2*y2 - a3*y3 - a4*y4;
        output[i] = y0;
        // Shift
        x4 = x3; x3 = x2; x2 = x1; x1 = x0;
        y4 = y3; y3 = y2; y2 = y1; y1 = y0;
    }
}

// Hàm tính nhịp tim (peak interval, đầu vào là mảng SensorData, trả về BPM)
static void calc_heart_rate_peak_interval(const SensorData *data, int dataSize, float fs, float *result) {
    float ir[dataSize];
    for (int i = 0; i < dataSize; i++) ir[i] = data[i].ir;
    float filtered[dataSize];
    bandpass_filter(ir, filtered, dataSize, fs);
    // Chuẩn hóa
    float mean = 0, std = 0;
    for (int i = 0; i < dataSize; i++) mean += filtered[i];
    mean /= dataSize;
    for (int i = 0; i < dataSize; i++) std += (filtered[i]-mean)*(filtered[i]-mean);
    std = sqrtf(std/dataSize);
    for (int i = 0; i < dataSize; i++) filtered[i] = (filtered[i]-mean)/std;
    // Tìm đỉnh
    int peaks[32]; int n_peaks = 0;
    int min_dist = (int)(fs*0.3f); // tối thiểu 0.3s giữa các đỉnh
    for (int i = 1; i < dataSize-1; i++) {
        if (filtered[i] > 0.2f && filtered[i] > filtered[i-1] && filtered[i] > filtered[i+1]) {
            if (n_peaks == 0 || (i - peaks[n_peaks-1]) > min_dist) {
                if (n_peaks < 32) peaks[n_peaks++] = i;
            }
        }
    }
    if (n_peaks < 2) { *result = 0; return; }
    float intervals_sum = 0;
    for (int i = 1; i < n_peaks; i++) intervals_sum += (peaks[i] - peaks[i-1]);
    float avg_interval = intervals_sum / (n_peaks-1) / fs;
    *result = 60.0f / avg_interval;
}

// Hàm tính SpO2 (Filtered AC/DC ratio, đầu vào là mảng SensorData, trả về %)
static void calc_spo2_filtered(const SensorData *data, int dataSize, float fs, float *result) {
    float ir[dataSize], red[dataSize];
    for (int i = 0; i < dataSize; i++) {
        ir[i] = data[i].ir;
        red[i] = data[i].red;
    }
    float ir_f[dataSize], red_f[dataSize];
    bandpass_filter(ir, ir_f, dataSize, fs);
    bandpass_filter(red, red_f, dataSize, fs);
    // AC là std, DC là mean
    float ir_ac=0, ir_dc=0, red_ac=0, red_dc=0;
    float ir_sum=0, red_sum=0;
    for (int i = 0; i < dataSize; i++) { ir_sum += ir[i]; red_sum += red[i]; }
    ir_dc = ir_sum / dataSize;
    red_dc = red_sum / dataSize;
    for (int i = 0; i < dataSize; i++) { ir_ac += (ir_f[i]-ir_dc)*(ir_f[i]-ir_dc); red_ac += (red_f[i]-red_dc)*(red_f[i]-red_dc); }
    ir_ac = sqrtf(ir_ac/dataSize);
    red_ac = sqrtf(red_ac/dataSize);
    if (ir_dc == 0 || red_dc == 0) { *result = 0; return; }
    float R = (red_ac/red_dc) / (ir_ac/ir_dc);
    float spo2 = 104.0f - 17.0f * R;
    if (spo2 < 0) spo2 = 0; if (spo2 > 100) spo2 = 100;
    *result = spo2;
}

#endif // VITAL_SIGNS_ALGO_H 
